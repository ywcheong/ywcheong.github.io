{"/fastapi-spooky-story/":{"data":{"":"","fastapi-개발-중-겪은-일#FastAPI 개발 중 겪은 일":"FastAPI를 활용한 새 웹 프로젝트를 개발하던 중 미스터리한 일을 겪었다. (스포일러: 귀신은 없었다.) 이번 프로젝트에서는 AWS를 사용해 프로덕션을 개발할 생각이었기에, 개발 환경은 AWS EC2로 세팅을 마쳤었다. Python 프로젝트는 여러 번 해 봤지만 FastAPI를 활용하는 경우는 처음이어서 간단한 데모 코드를 가지고 원리를 이해하고 있었다.\n당시 개발 화면 당시 개발 중이던 환경은 위 화면과 같았는데, Visual Studio Code에 Remote-SSH 익스텐션을 설치해서 원격으로 EC2 Instance에 접속하였었다. 사진이 작아서 잘 안 보이기는 하지만, 화면을 보면 당시 AWS EC2에 부여된 Public IP가 172.31.3.163임을 알 수 있다.\nFastAPI에서는 서버를 실행하기 위해 fastapi dev my-file.py와 같은 명령을 실행하는데, 그 결과로 아래와 같은 출력을 얻을 수 있었다.\n╭────────── FastAPI CLI - Development mode ───────────╮ │ │ │ Serving at: http://127.0.0.1:8000 │ │ │ │ API docs: http://127.0.0.1:8000/docs │ │ │ │ Running in development mode, for production use: │ │ │ │ fastapi run │ │ │ ╰─────────────────────────────────────────────────────╯ 여기서 주목할 점은 FastAPI 서버가 http://127.0.0.1:8000에 개방되었다는 정보이다. EC2 보안그룹 정책을 통해 당시 8000번 포트는 접속을 개방한 상태였다.\nAWS 보안그룹 설정, 8000번 포트가 모든 IP에 대해 개방되어 있다. 따라서 내 생각으로는 Public IP가 172.31.3.163이고, 8000번 포트가 개방되었으니 내 브라우저에서 http://172.31.3.163:8000으로 접근하면 테스트 서버에 접속할 수 있겠다는 판단이었다.","귀신-들린-컴퓨터#귀신 들린 컴퓨터":"그러나 뜻밖의 일이 일어났다. http://172.31.3.163:8000은 Timeout이 뜨면서 접속이 되지 않았다. 왜 이러나 싶어서 VPC 설정이 잘못된 건지, 새 프로젝트를 시작하면서 새로 만든 서브넷의 설정이 망가진 건지, 라우팅 테이블은 멀쩡한지 다 뒤져봤다.\n아무리 찾아도 문제가 해결되지 않던 중, 혹시나 하는 생각에 http://127.0.0.1:8000로 접속을 시도해 봤더니…\n아무 설정도 안 했는데 내 컴퓨터에서 원격 PC에 접속이 된다? 여기서부터 뭔가 이상해졌다. 내가 설정한 건 SSH지 VPN이 아니었는데, 왜 localhost에서 EC2 인스턴스랑 연결이 되는 거지? 이때 별 생각을 다 하면서 구글링을 했는데, 너무 연관된 주제가 많다 보니 키워드 산정부터 어려움이 있었다. 당시 상황을 종합하면\nAWS EC2랑 SSH로 연결해 FastAPI Dev Server를 Public IP로는 접속이 안 되지만 Localhost에서는 접속이 됨 이었는데, 연결된 의존성이 많다 보니 검색 키워드도 제대로 나오지 않았다.\n이 시점에서 FastAPI 배우기는 우선순위에서 밀려나 버렸고, 나는 지금 당장 이게 왜 작동하는지 알고 싶었다. 이를 해결하고자 이 이상현상의 잠재적 원인은 AWS, SSH, FastAPI 중 한 곳에 있을 것이라는 가설을 세우고 각각 검증하기로 결정했다.","문제의-원인---가설#문제의 원인 - 가설":"AWS가 문제다? AWS 설정을 처음부터 다시 다 확인했지만 이상은 없었고, 따지고 보면 AWS가 문제일 가능성은 낮았다. AWS가 잘못되었다면 연결이 아예 안 되었으면 안 되었지, localhost에서 연결이 되는 건 AWS로 설명하기 힘들었다.\nSSH가 문제다? SSH가 문제가 있을 가능성이 높아 보였다. 어찌됐든 Remote와 Local을 잇는 거의 직접적인 bridge이기 때문이었다. 그러나 어떻게 연결이 SSH 밖으로 “샐” 수 있는지는 미지수였고, 따라서 FastAPI와 연관이 있을 것이라고 생각했다.\nFastAPI가 문제다? 아무래도 FastAPI 자체에 뭔가 기능이 있는 것 같았다. 이때 내가 세운 가설은 FastAPI의 fastapi dev my-file.py를 실행하는 과정에서 현재 환경이 SSH인지 아닌지를 판단하여, SSH일 경우 자동으로 추가 연결을 수립하는 숨겨진 매커니즘이 있을 것이라고 생각했다.\nUVicorn이 문제다? FastAPI Document를 뒤지던 중 FastAPI의 서버 구현은 UVicorn이라는 오픈소스에 의존한다는 것을 알게 되었다. 이떄 Uvicorn SSH와 같은 키워드로 검색을 해 보았지만, SSH 환경일 경우에만 발동하는 특별 기능이 있다는 말은 없었다.\n뜻밖의 장소에서 얻어낸 힌트 여기까지 오도록 문제가 해결될 기미는 안 보였는데, 그러던 중 우연히 실마리를 하나 찾게 된다. 검색 중에 Visual Studio Code가 아니라 Git Bash로 SSH에 접속해 fastapi dev my-file.py를 실행했더니, 더 이상 localhost:8000으로 웹페이지에 접속할 수 없었다. 이상함을 느끼고 다시 Visual Studio Code로 SSH를 연결했더니 이번에는 접속이 되었다. 이 상황을 실마리 삼아 vscode ssh remote localhost라고 구글에 검색해보게 되었고, 이 시점에서 문제의 원인이 명확해졌다.","문제의-원인---정답#문제의 원인 - 정답":"2021년에 나와 같은 문제를 겪고 있는 사람이 작성한 블로그에서 정답을 알 수 있었다. Vscode에서 SSH로 접속할 때는 그냥 접속하지 않고 Remote-SSH라는 익스텐션을 사용한다. 이 플러그인에는 Port Forwarding이라는 기능이 내장되어 있는데, 원격 서버의 Port와 로컬 머신의 Port를 바인딩해 주는 기능이다. 사실 기본 SSH에서도 이 기능이 있는데, 가장 큰 차이점은 Remote-SSH는 자동으로 Port를 탐지해 Port forwarding을 수행해 준다.\nSSH를 평소에 엄청나게 자주 쓰기 때문에 이런 기능이 존재한다는 것은 들었던 적이 있었다. 하지만 지금까지는 이 기능을 굳이 쓸 일이 없었기에 잊고 있었던 데다, 무엇보다도 Vscode가 자동으로 Port forwarding을 할 줄은 몰랐었다.\nMicrosoft 개발자가 직접 남긴 구현 코멘트에 따르면 해당 익스텐션은 설정에 따라 두 가지 방법으로 자동으로 포트를 탐지한다.\n현재 실행 중인 프로세스 중, 열린 포트를 가진 프로세스를 탐지 터미널 출력에서 URL + 포트 형식을 가진 출력이 있는지 탐지 실제로 이 사실을 알고 다시 Vscode를 확인해 보니 아래와 같은 탭을 발견할 수 있었다.\nRemote 8000번 포트가 localhost:8000로 Forward되고 있다. 사실, 이 문제는 두 가지 문제가 결합한 문제였다. localhost에서 접속이 되는 것도 문제지만, Public IP를 통해서는 접속할 수 없었던 것을 기억하는가? FastAPI dev 서버에서 Public IP를 통해 접속을 허용하려면 사실은 아래와 같은 옵션을 주어야 했다.\nfastapi dev my-file.py --host 0.0.0.0 이 옵션을 주고 실행하면, (보안 설정이 문제 없다는 가정 하에) Public IP를 사용해 http://172.31.3.163:8000로도 접근할 수 있다. ■"},"title":"FastAPI 개발 중에 귀신들린 이야기 (feat. VSCode)"},"/python-recursion-bug/":{"data":{"":"","결론부터-말하자면#결론부터 말하자면\u0026hellip;":"결론부터 말하자면… 알고리즘 문제풀이에 Python을 사용할 경우 sys.setrecursionlimit의 기본 한계인 1000을 초과하는 로직이 있을 경우 재귀함수가 아닌 일반함수로 구조를 바꾸거나, 또는 C, C++로의 변경을 고려하는 것이 좋다. 그렇지 않을 경우 Windows에서 탐지가 불가능한 치명적인 버그가 발생할 위험이 있다.","그래서-어떻게-해야-하는데#그래서 어떻게 해야 하는데?":"근본적인 문제 해결을 위해서는 재귀 함수를 사용하지 않는 것이 좋다. 하지만 PS를 하다 보면 재귀함수가 훨씬 직관적으로 해답을 생성한다는 것도 사실이다.\n사실 많은 경우 C, C++ 등의 언어로 PS를 하기 때문에 이런 문제를 겪지 않는다. C나 C++은 꼬리 재귀 최적화를 지원하지만 Python은 그렇지 않기 때문에 리소스 사용에서도 큰 차이를 보이기 때문이다. 당장 위의 문제를 일으킨 코드도 C로 변환하면 10ms도 걸리지 않는다.\n따라서 다음과 같은 방법이 가장 적절해 보인다.\nC, C++을 쓴다면.. 꼬리 재귀 최적화를 활용해 재귀함수를 주의하여 활용한다. Python 또는 다른 언어를 쓴다면… Recursion Depth가 작을 때만 (\u003c 1,000) 재귀함수를 사용한다. 그럼에도 재귀의 오버헤드는 무시할 수 없기에, 가급적이면 재귀를 사용하지 않는다. sys.setrecursionlimit 등으로 임의로 재귀깊이 제한을 해제하는 것은 매우 주의한다. (2025.05.20. 업데이트) 사실 재귀함수는 굳이 성능 문제가 아니더라도 실무에서 사용하는 데는 어느 정도의 위험성을 감수해야 한다는 사실을 추가로 알게 되었다. ISO 26262 등 미션 크리티컬 시스템을 위한 산업 표준에서는 재귀호출을 명시적으로 금지하는 경우가 많은데, 이는 코드의 정적분석을 어렵게 하고 재귀깊이를 통제하기 어려운 경우가 많기 때문이다. 물론 코딩 테스트 문제를 풀면서 이러한 사항을 모두 고려하는 것은 지나친 오버엔지니어링으로 볼 수도 있으나, 재귀호출에 따르는 비용을 명시적으로 이해하는 것도 중요하다는 점을 다시 한 번 강조하고 싶다.","문제의-시작#문제의 시작":"일의 시작은 백준 11049(행렬 곱셈 순서) 문제를 풀던 때였다. 해당 문제는 전형적인 메모이제이션을 활용한 동적 계획법 문제로, 재귀함수로 푸는 것이 그 구조상 깔끔하여 재귀함수를 통해 문제를 해결하고자 하였다.\n알고리즘 문제는 C, C++를 활용해 푸는 것이 좋지만 Python으로 진행한 프로젝트도 많았고 평소에도 자주 쓰는 언어였기에 별 생각 없이 풀었는데, Python에서 시간제한이 빡빡하게 설정되어 있던 문제라 시간 초과 오류를 몇 번 받았다. (참고로 해당 코드는 ChatGPT에게 C로 변환하라고 지시한 뒤 실행하면 10ms 안에 실행되었다.) 따라서 프로그램의 어느 부분이 느린지 분석하고자 커다란 테스트케이스를 만들어서 입력으로 넣어보았다.\n원래의 문제를 간단히 설명하면 n개의 행렬을 곱하는 가장 효율적인 문제였는데, 이때 n이 500 이하였다. 이때 문득 n이 더 크면 어떨지 궁금해져서 테스트케이스를 n = 5000짜리로 생성해서 집어넣게 되었다.\nmatrix_size = 5000이다. 그랬더니 놀랍게도 프로그램은 즉시 실행을 종료했고, 어떠한 출력도 내뱉지 않았다.\n당시 상황 재연. 프로그램의 출력이 없다. 화면에는 나타나지 않았지만 Python에서 PS를 하다 보면 흔한 오류인 RecursionError도 아니었다. 오류나 다른 특이 메시지도 없었기 때문이었다. 무엇보다도 n이 적당히 작으면(예: n = 500) 이런 문제 없이 정상적으로 프로그램이 실행되었다.\n문제를 해결하려 여러 번 검색했지만 생각보다 국내외 웹에서 관련 원인에 대해 정리된 자료를 찾기 힘들어서 직접 정리하였다.","문제의-재현-방법#문제의 재현 방법":"사실 위 문제는 아주 간단한 Python 코드로 쉽게 재현할 수 있다.\nimport sys sys.setrecursionlimit(10000010) def recursion(n): if n == 0: return 0 return n + recursion(n-1) print(\"Program Start\") print(recursion(10000000)) print(\"Program End\") 위 코드를 Windows 환경의 터미널에서 python3 script.py와 같이 실행하면 “Program Start” 이후로 아무 출력 없이 명령이 종료되고, Python REPL에서 실행시키면 REPL 자체가 죽어 버린다. 이는 Python Bugtracker Issue#45645에도 이미 보고되어 있다.\n이슈의 내용을 요약하면 Windows 환경에서 재귀함수가 지나치게 깊어지면 Stack Overflow 에러가 발생하는데, Windows 환경에서는 이 오류를 catch할 수 있는 적절한 방법을 구현할 수 없어 Python이 죽어 버리는 것이다. Windows에서는 프로그램이 스택 사이즈를 초과하면 프로세스를 즉시 종료하므로 해당 버그는 “수정 없을 것(Won’t Fix)“이라는 태그로 종결되었다. 엄밀히 말하자면 Guard Page 영역을 생성하는 등 방어는 가능하지만, 깊은 재귀함수를 사용하지 않는 일반적인 Python 프로그램에서 발생하는 오버헤드 등을 고려할 때 도입하지 않은 것으로 보인다.\nLinux에서는 일어나지 않는 버그 Windows에서 작동하지 않는 이 코드는, Linux에서는 0.01초 이내로 실행된다. 사진은 Amazon EC2 Linux 환경. Linux에서는 이 버그가 나타나지 않는다. 위의 실행 결과는 setrecursionlimit의 값을 21억까지 매우 크게 늘려도 작동했는데, 그 이유는 Linux와 Windows가 기본적으로 프로세스의 스택 크기 제한을 처리하는 방법이 다르기 때문이다.\nPython module - resource 공식 문서에 따르면 Linux에서는 스택 크기를 직접 통제할 수 있는 resoruce 모듈을 제공하지만 Windows에서는 그렇지 않다. 그 이유는 resource 모듈은 linux의 setrlimit이라는 시스템 콜을 사용하기 때문이지만, Windows에서는 프로그램 실행 중에 동적으로 스택 크기를 제어하는 기능을 제공하지 않기 때문이다. Windows에서 스택 영역을 굳이 런타임에 추가로 사용하고 싶다면, 새로운 쓰레드를 생성해 해당 스택 영역을 활용하는 등 간접적인 방법 외에는 존재하지 않는다. 또한 Windows에서는 기본 스택의 크기가 Linux에 비해 작은 편이다.\n⚠️ Linux와 Windows 간의 기본 스택 크기는 컴파일 옵션이나 Linux의 ulimit -s stack_size 명령 등으로 그 대소관계가 쉽게 바뀔 수 있다는 점을 유의해야 한다. 그러나 Windows가 런타임에서 직접적인 방법으로 동적으로 스택 크기를 변화시킬 수 없다는 것은 여전히 유효하기에 상황이 크게 바뀌지는 않는다. 정리하자면, Linux는 Windows와 달리\n스택 영역을 실행 중에 동적으로 확장할 수 있고 (항상 그렇다고는 할 수 없지만) 기본 스택 크기도 큰 편임 이라는 요인이 맞물려져 이러한 차이가 발생한 것으로 보인다."},"title":"sys.setrecursionlimit(10**6)은 만능 해결사가 아니다"},"/python2-input-eval/":{"data":{"":"","easyplotlib-request-설계#Easyplotlib request 설계":"","easyplotlib-구조-만들기#Easyplotlib 구조 만들기":"","logfire와-pydantic의-연동#Logfire와 Pydantic의 연동":"","pydantic-패키지로-검증하기#Pydantic 패키지로 검증하기":"","배운-점#배운 점\u0026hellip;":"Easyplotlib 구조 만들기 Easyplotlib을 개발하면서 제일 먼저 시작했던 부분은 Frontend와 Backend 사이의 통신 양식을 정하는 것이었다. 이 프로젝트를 간단히 설명하면 (인공지능은 아니지만) 사용자를 대신해 사용자의 요구대로 자동으로 코드를 생성해 주고, 이를 실행한 뒤 그 결과를 보여주는 게 주 기능이다. 코드를 동적으로 생성한 뒤 실행한다는 특성상 잘못된 방식으로 구조를 설계할 경우 ACE (Arbitrary Code Execution; 임의 코드 실행) 취약점이 발생할 우려가 컸기에, 상당히 신경써서 만들어야겠다는 생각이었다.\n임의 코드 실행 취약점 브라우저상에서 직접 코드를 생성해서 서버로 보낸 뒤 실행하는 방법은 너무 간단하지만, 보안에 대해 조금이라도 알고 있다면 절대적으로 피해야 할 개발 방법이라는 것을 알 수 있다. 서버에서 기대한 코드는 matplotlib.pyplot.plot() 같은 순한 함수였겠지만 실제로는 이런 코드가 날아올 수 있기 때문이다.\nimport subprocess subprocess.run(['rm', '-rf', '/', '--no-preserve-root']) Python 2의 input()은 위험하다 Python 2의 예시를 들자면, 사용자의 터미널 입력을 받는 함수는 raw_input()과 input()으로 두 가지가 있었다. raw_input()은 Python 3의 input()과 같이 항상 str 타입을 반환하지만 input()은 가능한 경우 자동으로 캐스팅을 해 주는 차이가 있어서 처음 Python을 배웠을 때 자주 애용했던 기억이 난다.\n# Python 2 \u003e\u003e\u003e raw_input() 3 # 입력 '3' # 출력 \u003e\u003e\u003e input() 3 # 입력 3 # 출력 그런데 사실 충격적인 점은 Python 2의 input() 구현은 eval(raw_input())이었다! 이로부터 야기되는 보안 이슈도 짐작이 가지 않을 정도로 거대했을 것이다.\nACE의 다른 예시를 들자면 C나 C++와 같이 메모리 영역에 직접 접근 가능한 언어에서 발생하는 버퍼 오버플로를 활용한 공격도 크게 보면 ACE 취약점의 일부로 볼 수 있겠다. 정상적인 방법으로는 실행되지 않는 사용자 입력 영역을 실행시킨다는 개념은 같기 때문이다.\n물론 위의 ACE 취약점을 예방하는 방법은 여러 가지가 있다. Python에서 파일 및 네트워킹 기능을 제거한 채 컴파일한 커스텀 언어를 사용할 수도 있꼬고, AWS를 활용해 가상화 레이어를 추가하거나, 특정 함수의 동작을 패턴 매칭이나 RestrictedPython 같은 외부 패키지로 제한할 수도 있다. 하지만 가장 좋은 것은 백준과 같은 온라인 저지처럼 ACE가 반드시 필요한 경우가 아니라면 이를 처음부터 예방하는 것이다.\nEasyplotlib request 설계 사실 Easyplotlib은 저런 이상한 설계를 애초부터 고려할 생각이 없었다. 데이터를 구조화할 수 있기 때문이다. 다만 문제가 있었다면 구조화된 데이터가 너무 복잡해 이를 검증할 코드를 처음부터 짜기가 상당히 피곤했다.\n아래 카드를 클릭하면 데이터의 ‘대충 버전’ 정의를 볼 수 있다. JSON 스키마 등으로 구조화되어 있지는 않고, 다만 설계 단계의 문서를 그대로 가져온지라 깔끔하지 않기는 하다.\n구조화된 데이터 보기 (JSON) request_id : Is uuid4 figure size row : Is numeric, plt.subplot(row, _) column : Is numeric, plt.subplot(_, column) axes [List] : length of figure.size.row [List] : length of figure.size.column Is one of axes[].name or null. Null axes will not be rendered, as it never exists style Every possible key-value pairs are defined at figure-style axes [List] name : Is string plot [List] Is one of plot[].name style Every possible key-value pairs are defined at axes-style plot [List] name : Is string format : Every possible values are defined at plot-format-list data key: Depending on plot[].format, there are different required and optional keys. Check plot-format-list. value: Is one of data[].name style Every possible key-value pairs are defined at plot-style data [List] name : Is string value [List] Is numeric 이 긴 JSON을 하나하나 수동으로 검증하는 것은 오류를 유발하기 쉬워 보였고, 곧 FastAPI 개발 도중 데이터를 깔끔하게 받을 수 있다는 이유로 사용을 추천한다고 어디선가 읽은 Pydantic 패키지에 대해 조사해보게 되었다.\nPydantic 패키지로 검증하기 Pydantic은 여러 기능이 있지만 데이터 검증 기능을 메인으로 내세우는 패키지이다. 기능 설명을 하면 너무 복잡해지지만, 아래와 같은 상황을 생각해 보자.\nclass User: name : str # 이름 age : int # 나이 spouce : Optional[User] # 배우자 friends : List[User] # 친구 Python에서는 Type hint를 통해 Linter의 작동을 보조할 수는 있지만 그것이 실제 데이터의 타입 일치를 보증해 주지는 않는다. 극단적으로는 위 코드에서는 다음 코드도 실제 에러를 일으키기 전까지는 (예: User(spouce=None).spouce.name) 어떠한 검증도 ‘직접’ 진행하지 않으면 오류가 숨게 된다. Pydantic의 유스케이스를 몇 개 나열하자면\n타입 강제 특정 데이터가 Type Hint를 따르도록 강제할 수 있음 Type을 따르지는 않지만 캐스팅이 가능한 경우 (예: '23' -\u003e 23) 자동 캐스팅을 허용할 수 있음 자동 캐스팅을 비활성화하거나 캐스팅이 불가한 경우 ValidationError를 발생 명시되지 않은 entry를 오류발생/무시/별도처리 등 조건지정 가능 복잡한 유효성 검사 Type만을 검사하는 것이 아닌, 복잡한 조건을 argument만으로 쉽게 부여할 수 있음 정수의 경우 최대-최소, 문자열의 경우 길이 조건 및 정규식 등 설정 가능 지나치게 복잡한 조건의 경우 검사함수를 직접 작성할 수 있음 모델 유효성 검사 각 entry만 검사하는 것이 아닌, 여러 entry 간의 상호관계를 기반으로 모델 유효성도 검사할 수 있음 (커스텀 함수) 예를 들어 if(self.spouce) assert(self.spouce.name != self.name)과 같은 복잡한 조건도 함수로 설정가능 클래스-JSON 상호변환 지원 클래스 인스턴스를 JSON으로, 또는 그 반대로 변환 가능 클래스 인스턴스 선언을 비롯한 모든 과정에서 별도의 함수호출 없이 자동으로 위의 유효성 검사가 수행됨 사실상 User Input Sanitization이 필요한 모든 곳에 사용할 수 있다. 이걸 진작 배웠으면 지금까지 한 프로젝트에서 이 고생은 안 해도 됐었을 것 같아서 안타까웠다.\nLogfire와 Pydantic의 연동 Pydantic 공식 사이트에 Logfire라고 Pydantic과 호환되는 로깅 툴이 있다. 이 패키지도 흥미로웠는데, 과거 내가 작성했던 프로젝트의 코드를 보면 그럴 수밖에 없었다.\n# 구 프로젝트 코드 (일부 변경됨) def putLog(name, action=None, data=None): if action is None: logging.info(\"{:\u003c29} | {:\u003c8} |\", get_current_time_ISO(), name ) elif data is None: logging.info(\"{:\u003c29} | {:\u003c8} | action = {:\u003c20}\".format( get_current_time_ISO(), name, action )) else: logging.info(\"{:\u003c29} | {:\u003c8} | action = {:\u003c20} | data = {}\".format( get_current_time_ISO(), name, action, data )) putLog(\"SystemComponentA\", \"auto-sync\", \"[sync-ratio = {:.3f}]\".format( theory_max )) 이렇게 누더기 같은 코드로 로깅을 했는데, 중복되는 코드도 너무 많고 오류의 가능성도 높아 바람직하지 않았기 때문이다.\n배운 점… 사실 지금까지 Pydantic을 안 배운 이유는 지금까지 Pydantic을 필요로 할 만큼 복잡한 데이터 Validation 로직이 필요 없었기 때문이다. 항상 하는 생각이지만 비즈니스 로직이 복잡해지면 주먹구구식에는 한계가 생기고, 이로 인해 새로운 기술을 배워야 하는 시점이 오는 것 같다. 그리고 새 기술을 배우고 나면 ‘이걸 진작 배울걸 왜 이제서야 활용할까’와 같은 생각이 든다.\n하지만 결국 필요를 느낀다면 무엇이든 배우게 되는 것 같다. 그리고 그 필요를 가장 빠르게 느낄 수 있는 곳은 결국 프로젝트 아닐까. 단일 책임 원칙도, 테스팅도, 커버리지도, AWS도, Python도, Websocket도, Agile도, OS도 결국 필요하면 배우게 된다. 귀납적으로 생각하면 Logfire도 필요를 느낀 미래의 내가 배우지 않을까, 아마도? 배우는 게 즐거운 것은 참 큰 축복이라고 생각한다.\n(2025.05.20. 업데이트) 실제로 곧 배우게 되었다. 사실 Python으로 주먹구구 개발을 할 때와는 다르게 Java Spring Boot 프레임워크를 활용해 보니 이러한 문제들에 대한 고민이 이미 상당히 정형화된 형태로 완성되어 있었다. 위 Pydantic에 대응하는 Spring 기능은 Validation 프레임워크이다. 또한 Logfire 기능은 Logback 등으로 역시 Java Spring에서 활용할 수 있다.\n또한 이러한 이슈들은 결국 운영과 연결되어 있다는 것도 알게 되었다. 단순한 개발 환경과는 다르게 실제 운영되는 서비스는 Logging, Observability, Error Handling 등이 매우 중요해지기 때문이다. 이 사례는 Spring Boot를 처음 배울 때, 중요하지만 비즈니스 로직과는 무관한 관점들을 분리한다는 Aspect Oriented Programming을 별다른 어려움 없이 쉽게 이해하는 데 큰 도움을 주었다. ■","임의-코드-실행-취약점#임의 코드 실행 취약점":""},"title":"Python 2에서 input()은 eval(raw_input())이다"}}