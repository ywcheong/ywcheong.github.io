{"/en/fastapi-spooky-story/":{"data":{"":"","an-unexpected-clue#An Unexpected Clue":"Up to this point, there was no sign of a solution. Then, by chance, I found a clue. While searching, I tried connecting to SSH using Git Bash instead of Visual Studio Code and ran fastapi dev my-file.py. This time, I could no longer access the web page via localhost:8000. Feeling something was off, I reconnected with Visual Studio Code, and this time it worked. Using this as a clue, I Googled “vscode ssh remote localhost” and at this point, the cause became clear.","hypotheses-about-the-cause#Hypotheses About the Cause":"Is it AWS?\nI checked all the AWS settings from scratch, but there was nothing wrong. If AWS was the problem, it would be hard to explain why I could connect via localhost but not at all otherwise.\nIs it SSH?\nSSH seemed more likely to be the problem. After all, it’s the direct bridge between Remote and Local. But I couldn’t figure out how the connection could “leak” outside SSH, so I thought it might be related to FastAPI.\nIs it FastAPI?\nI thought there might be some feature in FastAPI itself. My hypothesis was that when running fastapi dev my-file.py, FastAPI might detect if it’s running in an SSH environment and automatically establish some hidden connection.\nIs it UVicorn?\nWhile looking through the FastAPI documentation, I found that FastAPI’s server implementation relies on the open-source UVicorn. I searched for keywords like Uvicorn SSH, but found no mention of any special feature that only activates in SSH environments.","the-cause-of-the-problem---the-answer#The Cause of the Problem - The Answer":"I found the answer in a blog post by someone who had the same problem in 2021. When you connect via SSH in VSCode, you don’t just connect; you use an extension called Remote-SSH. This plugin has a built-in feature called Port Forwarding, which binds the remote server’s port to your local machine’s port. In fact, basic SSH also has this feature, but the key difference is that Remote-SSH automatically detects ports and performs port forwarding for you. Because I use SSH so often, I had heard that such a feature existed. But I had never needed to use it before, so I forgot about it, and above all, I didn’t know that VSCode would automatically do port forwarding.\nAccording to a comment by a Microsoft developer, the extension automatically detects open ports in two ways, depending on settings:\nDetects processes with open ports among currently running processes Detects terminal output containing a URL + port format After learning this, I checked VSCode again and found the following tab.\nRemote port 8000 is being forwarded to localhost:8000. Actually, this problem was a combination of two issues. Remember, not only was it strange that I could connect via localhost, but I also couldn’t connect via Public IP? To allow connections via Public IP in the FastAPI dev server, you actually need to add the following option:\nfastapi dev my-file.py --host 0.0.0.0 If you run it with this option (assuming your security settings are correct), you can also access it via http://172.31.3.163:8000 using the Public IP. ■","the-experience-while-developing-with-fastapi#The Experience While Developing with FastAPI":"While developing a new web project using FastAPI, I encountered a mysterious incident. (Spoiler: There were no ghosts.) For this project, I planned to use AWS for production, so I had already set up my development environment on AWS EC2. Although I had done several Python projects before, this was my first time using FastAPI, so I was trying to understand the basics with a simple demo code.\nDevelopment screen at the time The environment I was developing in looked like the screen above. I installed the Remote-SSH extension in Visual Studio Code to connect to the EC2 Instance remotely. Although the screenshot is small and hard to see, you can tell that the AWS EC2 was assigned the Public IP 172.31.3.163.\nTo run the server in FastAPI, you execute a command like fastapi dev my-file.py, and you get output like the following:\n╭────────── FastAPI CLI - Development mode ───────────╮ │ │ │ Serving at: http://127.0.0.1:8000 │ │ │ │ API docs: http://127.0.0.1:8000/docs │ │ │ │ Running in development mode, for production use: │ │ │ │ fastapi run │ │ │ ╰─────────────────────────────────────────────────────╯ The point to note here is that the FastAPI server is open at http://127.0.0.1:8000. The EC2 security group policy had already opened port 8000 at the time.\nAWS security group setting, port 8000 is open to all IPs. So, I thought, since the Public IP is 172.31.3.163 and port 8000 is open, I should be able to access the test server from my browser at http://172.31.3.163:8000.","the-haunted-computer#The Haunted Computer":"But something unexpected happened. http://172.31.3.163:8000 timed out and could not be accessed. Wondering if the VPC settings were wrong, or if the subnet I created for the new project was misconfigured, or if the routing table was broken, I checked everything.\nAfter checking everything and still not finding the problem, I tried accessing http://127.0.0.1:8000 just in case…\nWithout any configuration, I can connect to the remote PC from my own computer? This is where things got weird. All I set up was SSH, not a VPN, so why was localhost connecting to the EC2 instance? I started Googling with all sorts of thoughts in mind, but there were so many related topics that even coming up with search keywords was difficult. Summing up the situation at the time:\nAWS EC2 Connected via SSH FastAPI Dev Server Cannot connect via Public IP Can connect via localhost Because there were so many dependencies, I couldn’t even come up with proper search keywords. At this point, learning FastAPI became a lower priority, and I just wanted to know why this was happening right now. To solve this, I hypothesized that the root cause of this strange phenomenon would be in one of AWS, SSH, or FastAPI, and decided to verify each."},"title":"A Haunted Story While Developing with FastAPI (feat. VSCode)"},"/en/python-recursion-bug/":{"data":{"":"","how-to-reproduce-the-problem#How to Reproduce the Problem":"Actually, this issue can be reproduced with a very simple Python script.\nimport sys sys.setrecursionlimit(10000010) def recursion(n): if n == 0: return 0 return n + recursion(n-1) print(\"Program Start\") print(recursion(10000000)) print(\"Program End\") If you run this code in a Windows terminal as python3 script.py, you’ll see “Program Start” and then the command will exit with no further output. If you run it in the Python REPL, the REPL itself will crash.\nThis has already been reported in Python Bugtracker Issue#45645. To summarize: When a recursive function gets too deep on Windows, a Stack Overflow error occurs. On Windows, there’s no way to properly catch this error, so Python just dies. When a program exceeds the stack size on Windows, the process is terminated immediately, and the bug was closed as “Won’t Fix.” Technically, it’s possible to create a Guard Page for protection, but considering the overhead and the fact that most Python programs don’t use such deep recursion, it hasn’t been implemented.\nThis Bug Does Not Occur on Linux This code, which doesn't work on Windows, runs in under 0.01 seconds on Linux. Screenshot from Amazon EC2 Linux. On Linux, this bug does not occur. Even with setrecursionlimit set to an extremely high value (e.g., 2.1 billion), the code runs fine. This is because Linux and Windows handle process stack size limits differently.\nAccording to the Python module - resource documentation, Linux provides the resource module to directly control stack size, but Windows does not. This is because the resource module uses the setrlimit system call in Linux, but Windows does not allow dynamic stack size changes at runtime. On Windows, if you want to use more stack space, you have to create a new thread with a larger stack, or use other indirect methods. Also, the default stack size on Windows is generally smaller than on Linux.\n⚠️ The default stack size can change easily depending on compiler options or commands like ulimit -s stack_size on Linux. However, the fact that Windows cannot dynamically change stack size at runtime remains true, so the situation doesn’t change much. In summary, Linux (unlike Windows):\nCan dynamically expand the stack at runtime (Usually, but not always) Has a larger default stack size These factors combine to create the observed differences.","so-what-should-you-do#So, What Should You Do?":"To fundamentally solve the problem, it’s best not to use recursion. But in PS (problem solving), recursion can be much more intuitive.\nIn most cases, C or C++ is used for PS, so this problem is less common. C and C++ support tail recursion optimization, but Python does not, leading to significant differences in resource usage. The code that caused the problem above runs in less than 10ms when converted to C.\nSo, the most appropriate approach is:\nIf using C or C++: Use recursion carefully, leveraging tail recursion optimization. If using Python or other languages: Use recursion only for small recursion depths (\u003c 1,000). Even then, be aware of the overhead, and avoid recursion when possible. Be very careful about arbitrarily increasing the recursion limit with sys.setrecursionlimit. (2025.05.20. Update) In fact, recursion carries risks even aside from performance. Industry standards for mission-critical systems, like ISO 26262, often explicitly prohibit recursion because it complicates static code analysis and makes recursion depth difficult to control. Of course, considering all these factors when solving coding test problems may be overengineering, but it’s important to understand the costs of recursion.","to-begin-with-the-conclusion#To Begin with the Conclusion\u0026hellip;":"To Begin with the Conclusion… When solving algorithm problems in Python, if your logic requires exceeding the default recursion limit of 1000, it’s better to refactor your code to use iterative functions or consider switching to C or C++. Otherwise, there is a risk of encountering fatal bugs on Windows that cannot be detected.","where-the-problem-started#Where the Problem Started":"This all began while I was solving Baekjoon 11049 (Matrix Chain Multiplication). This problem is a classic dynamic programming question where memoization is used, and recursion makes the structure clean and intuitive.\nAlthough C or C++ is generally recommended for algorithm problems, I often use Python for various projects and felt comfortable using it here. However, due to the tight time limits set for the problem, I encountered several time limit errors. (For reference, after converting the code to C via ChatGPT, it ran in under 10ms.) To analyze which part of the program was slow, I created a large test case and fed it as input.\nThe problem was about finding the most efficient way to multiply n matrices, and n was less than 500. I became curious about what would happen if n was larger, so I generated a test case with n = 5000.\nmatrix_size = 5000. Surprisingly, the program terminated immediately with no output whatsoever.\nReenactment of the situation. No output from the program. Although not shown, the program had ended. There was no RecursionError, which is a common error when doing PS (problem solving) in Python. There were no error messages or anything unusual. Most importantly, if n was reasonably small (e.g., n = 500), the program ran just fine.\nI searched many times for a solution, but found very little documentation on the root cause, so I decided to summarize it myself."},"title":"sys.setrecursionlimit(10**6) Is NOT a Silver Bullet"},"/en/python2-input-eval/":{"data":{"":"","arbitrary-code-execution-vulnerability#Arbitrary Code Execution Vulnerability":"","building-the-easyplotlib-structure#Building the Easyplotlib Structure":"","easyplotlib-request-design#Easyplotlib Request Design":"","integrating-logfire-and-pydantic#Integrating Logfire and Pydantic":"","validation-with-the-pydantic-package#Validation with the Pydantic Package":"","what-i-learned#What I Learned\u0026hellip;":"Building the Easyplotlib Structure The very first step I took while developing Easyplotlib was to define the communication protocol between the frontend and backend. To briefly explain this project, its main function is to automatically generate code according to the user’s requirements (though it’s not AI), execute it, and then show the results. Since the project dynamically generates and executes code, I was very mindful of the risk of introducing ACE (Arbitrary Code Execution) vulnerabilities if the structure was poorly designed.\nArbitrary Code Execution Vulnerability Generating code directly in the browser and sending it to the server for execution is far too simple, but anyone with even a basic understanding of security would know to absolutely avoid this development method. The server might expect harmless code like matplotlib.pyplot.plot(), but in reality, code like the following could be sent:\nimport subprocess subprocess.run(['rm', '-rf', '/', '--no-preserve-root']) Python 2’s input() Is Dangerous For example, in Python 2, there were two functions for receiving user input from the terminal: raw_input() and input(). raw_input() always returns a str type, just like Python 3’s input(), but input() would automatically cast the input if possible, which made it popular when I first learned Python.\n# Python 2 \u003e\u003e\u003e raw_input() 3 # input '3' # output \u003e\u003e\u003e input() 3 # input 3 # output But the shocking truth is that Python 2’s input() implementation was actually eval(raw_input())! The security issues that could arise from this are almost unimaginable.\nAnother example of ACE is buffer overflow attacks in languages like C or C++ that allow direct access to memory. These can also be considered a type of ACE vulnerability, since the concept is the same: executing code in user input areas that would not normally be executed.\nOf course, there are many ways to prevent the above ACE vulnerabilities. In Python, you could use a custom language compiled with file and networking features removed, add a virtualization layer using AWS, or restrict certain functions with pattern matching or external packages like RestrictedPython. But the best approach is to prevent ACE from the start unless it’s absolutely necessary, like in online judges such as Baekjoon.\nEasyplotlib Request Design Actually, Easyplotlib never considered such a problematic design in the first place, since the data could be structured. The only issue was that the structured data was so complex that writing code to validate it from scratch seemed quite tedious.\nClick the card below to see a ‘rough version’ of the data definition. It’s not structured as a JSON schema, and since it’s taken directly from the design document, it’s not very clean.\nView Structured Data (JSON) request_id : Is uuid4 figure size row : Is numeric, plt.subplot(row, _) column : Is numeric, plt.subplot(_, column) axes [List] : length of figure.size.row [List] : length of figure.size.column Is one of axes[].name or null. Null axes will not be rendered, as it never exists style Every possible key-value pairs are defined at figure-style axes [List] name : Is string plot [List] Is one of plot[].name style Every possible key-value pairs are defined at axes-style plot [List] name : Is string format : Every possible values are defined at plot-format-list data key: Depending on plot[].format, there are different required and optional keys. Check plot-format-list. value: Is one of data[].name style Every possible key-value pairs are defined at plot-style data [List] name : Is string value [List] Is numeric Manually validating this long JSON would be error-prone, so I soon started researching the Pydantic package, which I had read is recommended for receiving clean data during FastAPI development.\nValidation with the Pydantic Package Pydantic offers many features, but its main selling point is data validation. To avoid making things too complicated, let’s consider the following situation:\nclass User: name : str # Name age : int # Age spouce : Optional[User] # Spouse friends : List[User] # Friends In Python, type hints can help linters, but they don’t guarantee actual data type consistency. In the extreme case above, the following code would not raise any error unless you explicitly validate it (e.g., User(spouce=None).spouce.name). Some use cases for Pydantic include:\nType enforcement Forcing specific data to follow type hints Allowing automatic casting if possible (e.g., '23' -\u003e 23) Disabling auto-casting or raising ValidationError if casting is not possible Handling unspecified entries with error, ignore, or custom conditions Complex validation Adding complex conditions beyond type checks easily via arguments For integers: min/max, for strings: length, regex, etc. For overly complex conditions, you can write custom validation functions Model validation Validating not just individual entries, but also inter-field relationships (custom functions) For example, if(self.spouce) assert(self.spouce.name != self.name) can be set as a function Class-JSON conversion support Convert class instances to JSON and vice versa All validation is performed automatically during class instantiation and everywhere else, with no extra function calls In fact, you can use it anywhere user input sanitization is needed. I regret not learning this sooner, as it would have saved me a lot of trouble in past projects.\nIntegrating Logfire and Pydantic On the Pydantic official site, there’s a logging tool called Logfire that’s compatible with Pydantic. I found this package interesting, and after looking at code from an old project, it made sense why.\n# Old project code (partially modified) def putLog(name, action=None, data=None): if action is None: logging.info(\"{:\u003c29} | {:\u003c8} |\", get_current_time_ISO(), name ) elif data is None: logging.info(\"{:\u003c29} | {:\u003c8} | action = {:\u003c20}\".format( get_current_time_ISO(), name, action )) else: logging.info(\"{:\u003c29} | {:\u003c8} | action = {:\u003c20} | data = {}\".format( get_current_time_ISO(), name, action, data )) putLog(\"SystemComponentA\", \"auto-sync\", \"[sync-ratio = {:.3f}]\".format( theory_max )) I used to log like this, but there was too much repetitive code and a high possibility of errors, which was not ideal.\nWhat I Learned… The reason I hadn’t learned Pydantic until now was simply that I never needed such complex data validation logic before. As always, when business logic gets complicated, there’s a limit to ad-hoc solutions, and that’s when you have to learn new technologies. And after learning something new, I always wonder, “Why didn’t I use this earlier?”\nBut in the end, you learn when you feel the need. And the fastest place to feel that need is always a project. Whether it’s the single responsibility principle, testing, coverage, AWS, Python, Websocket, Agile, or OS, I learned them because I needed them. Inductively, I guess my future self will learn Logfire too, when the need arises. I think it is a great blessing to enjoy learning.\n(Update: 2025.05.20.) I actually did end up learning it. Unlike my previous ad-hoc Python development, using the Java Spring Boot framework showed me that these issues are already formalized solutions. The Spring equivalent of Pydantic is the Validation framework, and for Logfire, you can use Logback in Java Spring.\nI also realized that these issues are ultimately connected to operations. Unlike simple development environments, real operating services make logging, observability, and error handling extremely important. This experience was a big help in understanding Aspect Oriented Programming, which separates these concerns from business logic, when I first learned Spring Boot. ■"},"title":"In Python 2, input() is eval(raw_input())"}}